// Code generated by protoc-gen-gogo.
// source: proxy.proto
// DO NOT EDIT!

/*
	Package rpc is a generated protocol buffer package.

	It is generated from these files:
		proxy.proto

	It has these top-level messages:
		StartProxyRequest
		StartProxyResponse
		StopProxyRequest
		StopProxyResponse
		ListRequest
		ListResponse
		ProxySpec
*/
package rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// StartProxyRequest is passed to the proxy service's Start endpoint.
type StartProxyRequest struct {
	Spec *ProxySpec `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
}

func (m *StartProxyRequest) Reset()                    { *m = StartProxyRequest{} }
func (m *StartProxyRequest) String() string            { return proto.CompactTextString(m) }
func (*StartProxyRequest) ProtoMessage()               {}
func (*StartProxyRequest) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{0} }

func (m *StartProxyRequest) GetSpec() *ProxySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// StartProxyResponse is returned by the proxy service's Start endpoint.
type StartProxyResponse struct {
}

func (m *StartProxyResponse) Reset()                    { *m = StartProxyResponse{} }
func (m *StartProxyResponse) String() string            { return proto.CompactTextString(m) }
func (*StartProxyResponse) ProtoMessage()               {}
func (*StartProxyResponse) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{1} }

// StopProxyRequest is passed to the proxy service's Stop endpoint.
type StopProxyRequest struct {
	Spec *ProxySpec `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
}

func (m *StopProxyRequest) Reset()                    { *m = StopProxyRequest{} }
func (m *StopProxyRequest) String() string            { return proto.CompactTextString(m) }
func (*StopProxyRequest) ProtoMessage()               {}
func (*StopProxyRequest) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{2} }

func (m *StopProxyRequest) GetSpec() *ProxySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// StopProxyResponse is returned by the proxy service's Stop endpoint.
type StopProxyResponse struct {
}

func (m *StopProxyResponse) Reset()                    { *m = StopProxyResponse{} }
func (m *StopProxyResponse) String() string            { return proto.CompactTextString(m) }
func (*StopProxyResponse) ProtoMessage()               {}
func (*StopProxyResponse) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{3} }

// ListRequest is the request passed to the proxy service's List endpoint.
type ListRequest struct {
}

func (m *ListRequest) Reset()                    { *m = ListRequest{} }
func (m *ListRequest) String() string            { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()               {}
func (*ListRequest) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{4} }

// ListResponse is returned by the proxy service's List endpoint.
type ListResponse struct {
	Proxies []*ProxySpec `protobuf:"bytes,1,rep,name=proxies" json:"proxies,omitempty"`
}

func (m *ListResponse) Reset()                    { *m = ListResponse{} }
func (m *ListResponse) String() string            { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()               {}
func (*ListResponse) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{5} }

func (m *ListResponse) GetProxies() []*ProxySpec {
	if m != nil {
		return m.Proxies
	}
	return nil
}

// ProxySpec defines the spec for creating a proxy.
type ProxySpec struct {
	// The protocol to proxy over (TCP or UDP).
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// Frontend is the frontend addr/port to proxy requests from.
	Frontend *ProxySpec_HostSpec `protobuf:"bytes,2,opt,name=frontend" json:"frontend,omitempty"`
	// Backend is the backend addr/port to proxy requests to.
	Backend *ProxySpec_HostSpec `protobuf:"bytes,3,opt,name=backend" json:"backend,omitempty"`
}

func (m *ProxySpec) Reset()                    { *m = ProxySpec{} }
func (m *ProxySpec) String() string            { return proto.CompactTextString(m) }
func (*ProxySpec) ProtoMessage()               {}
func (*ProxySpec) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{6} }

func (m *ProxySpec) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ProxySpec) GetFrontend() *ProxySpec_HostSpec {
	if m != nil {
		return m.Frontend
	}
	return nil
}

func (m *ProxySpec) GetBackend() *ProxySpec_HostSpec {
	if m != nil {
		return m.Backend
	}
	return nil
}

// Hostspec is an address and port definition.
// It is used to define a frontend or backend proxy definition.
type ProxySpec_HostSpec struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Port uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *ProxySpec_HostSpec) Reset()                    { *m = ProxySpec_HostSpec{} }
func (m *ProxySpec_HostSpec) String() string            { return proto.CompactTextString(m) }
func (*ProxySpec_HostSpec) ProtoMessage()               {}
func (*ProxySpec_HostSpec) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{6, 0} }

func (m *ProxySpec_HostSpec) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *ProxySpec_HostSpec) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func init() {
	proto.RegisterType((*StartProxyRequest)(nil), "StartProxyRequest")
	proto.RegisterType((*StartProxyResponse)(nil), "StartProxyResponse")
	proto.RegisterType((*StopProxyRequest)(nil), "StopProxyRequest")
	proto.RegisterType((*StopProxyResponse)(nil), "StopProxyResponse")
	proto.RegisterType((*ListRequest)(nil), "ListRequest")
	proto.RegisterType((*ListResponse)(nil), "ListResponse")
	proto.RegisterType((*ProxySpec)(nil), "ProxySpec")
	proto.RegisterType((*ProxySpec_HostSpec)(nil), "ProxySpec.HostSpec")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Proxy service

type ProxyClient interface {
	// Start starts up a new proxy.
	StartProxy(ctx context.Context, in *StartProxyRequest, opts ...grpc.CallOption) (*StartProxyResponse, error)
	// Stop stops an existing proxy.
	StopProxy(ctx context.Context, in *StopProxyRequest, opts ...grpc.CallOption) (*StopProxyResponse, error)
	// List lists all the running proxies
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
}

type proxyClient struct {
	cc *grpc.ClientConn
}

func NewProxyClient(cc *grpc.ClientConn) ProxyClient {
	return &proxyClient{cc}
}

func (c *proxyClient) StartProxy(ctx context.Context, in *StartProxyRequest, opts ...grpc.CallOption) (*StartProxyResponse, error) {
	out := new(StartProxyResponse)
	err := grpc.Invoke(ctx, "/Proxy/StartProxy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) StopProxy(ctx context.Context, in *StopProxyRequest, opts ...grpc.CallOption) (*StopProxyResponse, error) {
	out := new(StopProxyResponse)
	err := grpc.Invoke(ctx, "/Proxy/StopProxy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := grpc.Invoke(ctx, "/Proxy/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Proxy service

type ProxyServer interface {
	// Start starts up a new proxy.
	StartProxy(context.Context, *StartProxyRequest) (*StartProxyResponse, error)
	// Stop stops an existing proxy.
	StopProxy(context.Context, *StopProxyRequest) (*StopProxyResponse, error)
	// List lists all the running proxies
	List(context.Context, *ListRequest) (*ListResponse, error)
}

func RegisterProxyServer(s *grpc.Server, srv ProxyServer) {
	s.RegisterService(&_Proxy_serviceDesc, srv)
}

func _Proxy_StartProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).StartProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Proxy/StartProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).StartProxy(ctx, req.(*StartProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_StopProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).StopProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Proxy/StopProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).StopProxy(ctx, req.(*StopProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Proxy/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Proxy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Proxy",
	HandlerType: (*ProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartProxy",
			Handler:    _Proxy_StartProxy_Handler,
		},
		{
			MethodName: "StopProxy",
			Handler:    _Proxy_StopProxy_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Proxy_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proxy.proto",
}

func (m *StartProxyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartProxyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProxy(dAtA, i, uint64(m.Spec.Size()))
		n1, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *StartProxyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartProxyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StopProxyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopProxyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProxy(dAtA, i, uint64(m.Spec.Size()))
		n2, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *StopProxyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopProxyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Proxies) > 0 {
		for _, msg := range m.Proxies {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProxy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProxySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProxy(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.Frontend != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProxy(dAtA, i, uint64(m.Frontend.Size()))
		n3, err := m.Frontend.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Backend != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProxy(dAtA, i, uint64(m.Backend.Size()))
		n4, err := m.Backend.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ProxySpec_HostSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxySpec_HostSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProxy(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProxy(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func encodeFixed64Proxy(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Proxy(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintProxy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *StartProxyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovProxy(uint64(l))
	}
	return n
}

func (m *StartProxyResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StopProxyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovProxy(uint64(l))
	}
	return n
}

func (m *StopProxyResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ListRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ListResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Proxies) > 0 {
		for _, e := range m.Proxies {
			l = e.Size()
			n += 1 + l + sovProxy(uint64(l))
		}
	}
	return n
}

func (m *ProxySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovProxy(uint64(l))
	}
	if m.Frontend != nil {
		l = m.Frontend.Size()
		n += 1 + l + sovProxy(uint64(l))
	}
	if m.Backend != nil {
		l = m.Backend.Size()
		n += 1 + l + sovProxy(uint64(l))
	}
	return n
}

func (m *ProxySpec_HostSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovProxy(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovProxy(uint64(m.Port))
	}
	return n
}

func sovProxy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProxy(x uint64) (n int) {
	return sovProxy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StartProxyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartProxyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartProxyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ProxySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartProxyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartProxyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartProxyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopProxyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopProxyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopProxyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ProxySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopProxyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopProxyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopProxyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxies = append(m.Proxies, &ProxySpec{})
			if err := m.Proxies[len(m.Proxies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProxy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frontend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Frontend == nil {
				m.Frontend = &ProxySpec_HostSpec{}
			}
			if err := m.Frontend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProxy
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Backend == nil {
				m.Backend = &ProxySpec_HostSpec{}
			}
			if err := m.Backend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxySpec_HostSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProxy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProxy
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProxy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProxy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProxy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProxy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProxy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProxy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProxy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProxy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProxy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProxy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProxy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProxy   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proxy.proto", fileDescriptorProxy) }

var fileDescriptorProxy = []byte{
	// 321 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x51, 0xb1, 0x4e, 0xc3, 0x30,
	0x10, 0x8d, 0x69, 0xa1, 0xed, 0xb5, 0x95, 0xda, 0x2b, 0x43, 0x94, 0x21, 0xaa, 0x2c, 0x90, 0x58,
	0x30, 0x52, 0x5a, 0x89, 0x9d, 0x89, 0x81, 0x01, 0x25, 0x5f, 0x90, 0x26, 0x46, 0xaa, 0x40, 0xb1,
	0xb1, 0x8d, 0x04, 0x7f, 0xc2, 0xc2, 0x97, 0xf0, 0x03, 0x8c, 0x7c, 0x02, 0x0a, 0x3f, 0x82, 0xec,
	0x26, 0x69, 0xd4, 0xc2, 0xc0, 0x66, 0xbf, 0x7b, 0xf7, 0xee, 0xee, 0x3d, 0x18, 0x4a, 0x25, 0x9e,
	0x5f, 0x98, 0x54, 0xc2, 0x08, 0xba, 0x80, 0x69, 0x62, 0x52, 0x65, 0x6e, 0x2d, 0x16, 0xf3, 0xc7,
	0x27, 0xae, 0x0d, 0x86, 0xd0, 0xd5, 0x92, 0x67, 0x3e, 0x99, 0x93, 0xb3, 0x61, 0x04, 0xcc, 0x15,
	0x13, 0xc9, 0xb3, 0xd8, 0xe1, 0xf4, 0x18, 0xb0, 0xdd, 0xa4, 0xa5, 0x28, 0x34, 0xa7, 0x11, 0x4c,
	0x12, 0x23, 0xe4, 0xbf, 0x94, 0x66, 0x76, 0x7c, 0xd3, 0x53, 0x09, 0x8d, 0x61, 0x78, 0xb3, 0xd6,
	0xa6, 0xd2, 0xa0, 0x4b, 0x18, 0x6d, 0xbe, 0x9b, 0x32, 0x9e, 0x40, 0xcf, 0x5e, 0xb0, 0xe6, 0xda,
	0x27, 0xf3, 0xce, 0x8e, 0x6c, 0x5d, 0xa2, 0xef, 0x04, 0x06, 0x0d, 0x8c, 0x01, 0xf4, 0xdd, 0xbd,
	0x99, 0x78, 0x70, 0xbb, 0x0c, 0xe2, 0xe6, 0x8f, 0x17, 0xd0, 0xbf, 0x53, 0xa2, 0x30, 0xbc, 0xc8,
	0xfd, 0x03, 0xb7, 0xe7, 0x6c, 0x2b, 0xc8, 0xae, 0x85, 0x36, 0x4e, 0xb9, 0x21, 0xe1, 0x39, 0xf4,
	0x56, 0x69, 0x76, 0x6f, 0xf9, 0x9d, 0xbf, 0xf9, 0x35, 0x27, 0x88, 0xa0, 0x5f, 0x83, 0x88, 0xd0,
	0x4d, 0xf3, 0x5c, 0x55, 0x3b, 0xb8, 0xb7, 0xc5, 0xa4, 0x50, 0xc6, 0xcd, 0x1e, 0xc7, 0xee, 0x1d,
	0xbd, 0x11, 0x38, 0x74, 0x9a, 0x78, 0x09, 0xb0, 0xf5, 0x1a, 0x91, 0xed, 0xa5, 0x15, 0xcc, 0xd8,
	0x2f, 0x61, 0x78, 0xb8, 0x84, 0x41, 0x63, 0x2d, 0x4e, 0xd9, 0x6e, 0x34, 0x01, 0xb2, 0x7d, 0xe7,
	0x3d, 0x3c, 0x85, 0xae, 0x35, 0x1b, 0x47, 0xac, 0x15, 0x41, 0x30, 0x66, 0xed, 0x04, 0xa8, 0x77,
	0x35, 0xf9, 0x28, 0x43, 0xf2, 0x59, 0x86, 0xe4, 0xab, 0x0c, 0xc9, 0xeb, 0x77, 0xe8, 0xad, 0x8e,
	0x9c, 0x9f, 0x8b, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xba, 0x0f, 0x60, 0x80, 0x5e, 0x02, 0x00,
	0x00,
}
